<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>俳句SQLデモ（SQLite / sql.js）</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif; max-width: 1040px; margin: 2rem auto; padding: 0 1rem; }
    header { display: flex; align-items: baseline; gap: .75rem; margin-bottom: 1rem; }
    h1 { font-size: 1.4rem; margin: 0; }
    small { opacity: .75; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    textarea { width: 100%; min-height: 240px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 14px; padding: .75rem; border-radius: .5rem; }
    .btns { display: flex; flex-wrap: wrap; gap: .5rem; margin: .75rem 0 1rem; }
    button { cursor: pointer; padding: .7rem 1rem; border-radius: .7rem; border: 1px solid #1e40af; background: #2563eb; color: #fff; font-weight: 600; letter-spacing: .02em; box-shadow: 0 1px 2px #0003; }
    button:hover { filter: brightness(1.05); }
    button:disabled { background: #9ca3af; border-color: #9ca3af; color: #1f2937; cursor: not-allowed; }
    .card { border: 1px solid #8884; border-radius: .7rem; padding: .8rem; }
    table { border-collapse: collapse; width: 100%; font-size: 14px; }
    th, td { border: 1px solid #8884; padding: .45rem .5rem; text-align: left; }
    th { background: #00000010; }
    .muted { opacity: .7; font-size: .9em; }
    .right { text-align: right; }
    code { background: #00000010; padding: .15rem .35rem; border-radius: .4rem; }
    footer { margin-top: 2rem; opacity: .8; font-size: .9em; }
    input, select { background: inherit; color: inherit; }
  </style>
  <!-- sql.js（WASM）をCDNから読み込み。必ず自前スクリプトより先に置く -->
  <script src="https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/sql-wasm.js"></script>
</head>
<body>
  <header>
    <h1>俳句SQLデモ（SQLite / sql.js）</h1>
    <small>1ファイル | サーバ不要 | 無料 | 学習用</small>
  </header>

  <div class="row">
    <section class="card">
      <h2 style="margin-top:0">1) クエリを実行</h2>
      <p class="muted">下のSQLを書き換えて <strong>実行</strong> を押してください。<br>例：<code>SELECT h.text, a.name, k.term, s.name FROM haiku h LEFT JOIN authors a ON h.author_id=a.id LEFT JOIN kigo k ON h.kigo_id=k.id LEFT JOIN seasons s ON k.season_id=s.id;</code></p>
      <textarea id="sqlInput"></textarea>

      <div class="btns">
        <button id="runBtn">▶ 実行（Ctrl/⌘+Enter）</button>
        <button data-snippet="SELECT * FROM haiku;">haiku 全件</button>
        <button data-snippet="SELECT * FROM kigo;">kigo 全件</button>
        <button data-snippet="SELECT h.id, h.text AS haiku, a.name AS author, k.term AS kigo, s.name AS season\nFROM haiku h\nLEFT JOIN authors a ON h.author_id=a.id\nLEFT JOIN kigo k ON h.kigo_id=k.id\nLEFT JOIN seasons s ON k.season_id=s.id\nORDER BY h.id;">JOIN サンプル（俳句×季語×季節）</button>
        <button data-snippet="SELECT s.name AS season, COUNT(*) AS haiku_count\nFROM haiku h\nLEFT JOIN kigo k ON h.kigo_id = k.id\nLEFT JOIN seasons s ON k.season_id = s.id\nGROUP BY s.name\nORDER BY haiku_count DESC;">集計サンプル（季節ごとの句数）</button>
        <button id="resetBtn" title="初期データを入れ直します">🗘 DBリセット</button>
      </div>

      <!-- かんたん検索UI -->
      <div class="card" style="margin-top:.75rem">
        <div style="display:flex; gap:.5rem; flex-wrap:wrap; align-items:center">
          <strong>かんたん検索：</strong>
          <input id="qInput" placeholder="キーワード（例：蛙 / 夏草 / 芭蕉 / 夏）" style="flex:1; min-width:220px; padding:.6rem .7rem; border-radius:.6rem; border:1px solid #8884;">
          <select id="qType" style="padding:.6rem .7rem; border-radius:.6rem; border:1px solid #8884;">
            <option value="text">句の本文</option>
            <option value="author">作者名</option>
            <option value="kigo">季語</option>
            <option value="season">季節</option>
          </select>
          <button id="qRun">検索</button>
        </div>
        <div style="margin-top:.5rem; display:flex; gap:.5rem; flex-wrap:wrap">
          <button class="chip" data-q="蛙" data-type="text">🐸 蛙を含む句</button>
          <button class="chip" data-q="芭蕉" data-type="author">👤 芭蕉の句</button>
          <button class="chip" data-q="夏草" data-type="text">☘️ 夏草</button>
          <button class="chip" data-q="夏" data-type="season">🌞 夏の句</button>
        </div>
      </div>

      <p id="status" class="muted">DB初期化待ち…</p>
    </section>

    <section class="card">
      <h2 style="margin-top:0">2) 結果</h2>
      <div id="result"></div>
      <p class="muted">複数の <code>SELECT</code> を書いた場合、順にすべて表示します。</p>
    </section>
  </div>

  <section class="card" style="margin-top:1rem">
    <h2 style="margin-top:0">このデモの中身（スキーマ・初期データ）</h2>
    <pre id="schemaView" style="white-space:pre-wrap"></pre>
  </section>

  <footer>
    <p>実装：<code>sql.js 1.10.2</code>（WASM）。<br>このページはローカル保存してダブルクリックで開けます（サーバ不要）。学習用途にどうぞ。</p>
  </footer>

  <script>
    let db, SQL;

    const DEFAULT_QUERY = `-- 例：季語と作者をJOINして俳句を一覧\nSELECT h.id, h.text AS haiku, a.name AS author, k.term AS kigo, s.name AS season\nFROM haiku h\nLEFT JOIN authors a ON h.author_id = a.id\nLEFT JOIN kigo k ON h.kigo_id = k.id\nLEFT JOIN seasons s ON k.season_id = s.id\nORDER BY h.id;`;

    // DOM 取得
    const el = (id) => document.getElementById(id);
    const sqlInput = el('sqlInput');
    const result = el('result');
    const status = el('status');
    const schemaView = el('schemaView');

    // sql.js 初期化（WASMの場所をCDNに固定）
    initSqlJs({ locateFile: f => `https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/${f}` })
      .then((SQLLib) => {
        SQL = SQLLib;
        db = new SQL.Database();
        seed();
        status.textContent = 'DB 初期化完了。サンプルデータ投入済み。';
        sqlInput.value = DEFAULT_QUERY;
        runQuery();
      })
      .catch((e) => {
        console.error(e);
        status.textContent = 'sql.js の読み込みに失敗しました。 ' + (e && e.message ? e.message : '');
      });

    // サンプルデータ投入（俳句用）
    function seed() {
      const schema = `\nPRAGMA foreign_keys = ON;\n\n-- 季節マスタ\nCREATE TABLE seasons (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL UNIQUE -- 春/夏/秋/冬/新年 など\n);\n\n-- 季語マスタ\nCREATE TABLE kigo (\n  id INTEGER PRIMARY KEY,\n  term TEXT NOT NULL UNIQUE,\n  reading TEXT,               -- よみがな\n  category TEXT,              -- 天文/地理/人事/動物/植物 など\n  season_id INTEGER NOT NULL,\n  FOREIGN KEY (season_id) REFERENCES seasons(id)\n);\n\n-- 作者\nCREATE TABLE authors (\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL UNIQUE,\n  birth_year INTEGER,\n  death_year INTEGER\n);\n\n-- 俳句\nCREATE TABLE haiku (\n  id INTEGER PRIMARY KEY,\n  text TEXT NOT NULL,\n  author_id INTEGER,\n  kigo_id INTEGER,\n  year INTEGER,              -- 作年（不詳ならNULL）\n  place TEXT,                -- 地点メモ\n  note TEXT,                 -- 備考\n  FOREIGN KEY (author_id) REFERENCES authors(id),\n  FOREIGN KEY (kigo_id) REFERENCES kigo(id)\n);\n`;

      const data = `\n-- 季節\nINSERT INTO seasons(id, name) VALUES\n  (1, '春'), (2, '夏'), (3, '秋'), (4, '冬'), (5, '新年');\n\n-- 季語（ごく一部の例）\nINSERT INTO kigo(id, term, reading, category, season_id) VALUES\n  (101, '蛙', 'かわず', '動物', 1),\n  (102, '夏草', 'なつくさ', '植物', 2),\n  (103, '蝉', 'せみ', '動物', 2),\n  (104, '時雨', 'しぐれ', '天文', 4),\n  (105, '冬隣', 'ふゆとなり', '時候', 3);\n\n-- 作者\nINSERT INTO authors(id, name, birth_year, death_year) VALUES\n  (201, '松尾芭蕉', 1644, 1694),\n  (202, '与謝蕪村', 1716, 1784),\n  (203, '小林一茶', 1763, 1828),\n  (204, '正岡子規', 1867, 1902),\n  (205, '現代作者', NULL, NULL);\n\n-- 俳句（学習用の少数例、出典略）\nINSERT INTO haiku(id, text, author_id, kigo_id, year, place, note) VALUES\n  (1,  '古池や 蛙飛びこむ 水の音',         201, 101, 1686, '江戸',        '春：蛙'),\n  (2,  '夏草や 兵どもが 夢の跡',             201, 102, 1689, '平泉',        '夏：夏草'),\n  (3,  '閑さや 岩にしみ入る 蝉の声',         201, 103, 1689, '山形・立石寺','夏：蝉'),\n  (4,  '初しぐれ 猿も小蓑を ほしげなり',     201, 104, NULL, '大津',        '冬：時雨'),\n  (5,  '冬隣 小屋の道具も 異動時期',         205, 105, 2024, '津軽',        '学習用ダミー（冬隣）'),\n  (6,  '目には青葉 山ほととぎす 初鰹',       202, 101, NULL, '江戸',        '※季語が複数入る例：実際は重複管理が必要'),\n  (7,  'やせ蛙 まけるな一茶 これにあり',     203, 101, NULL, '信州',        '蛙（励まし）'),\n  (8,  '柿くへば 鐘が鳴るなり 法隆寺',       204, NULL, 1895, '奈良',        '季語：柿（本デモでは未登録）');\n`;

      db.run('DROP TABLE IF EXISTS haiku;');
      db.run('DROP TABLE IF EXISTS authors;');
      db.run('DROP TABLE IF EXISTS kigo;');
      db.run('DROP TABLE IF EXISTS seasons;');
      db.run(schema);
      db.run(data);

      schemaView.textContent = schema + '\n' + data;
    }

    // クエリ実行
    function runQuery() {
      clearResults();
      const sql = sqlInput.value.trim();
      if (!sql) return;
      const start = performance.now();
      try {
        const results = db.exec(sql); // 複数ステートメント対応
        if (!results.length) {
          appendInfo('実行完了（返す結果セットなし）。');
        } else {
          results.forEach(drawTable);
        }
        const ms = Math.round((performance.now() - start) * 100) / 100;
        appendInfo(`完了：${ms} ms`);
      } catch (e) {
        appendError(e.message || String(e));
      }
    }

    // 表描画
    function drawTable(res) {
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      res.columns.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      res.values.forEach(row => {
        const tr = document.createElement('tr');
        row.forEach((cell) => {
          const td = document.createElement('td');
          td.textContent = cell;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);

      result.appendChild(table);
    }

    function appendInfo(msg) {
      const p = document.createElement('p');
      p.className = 'muted';
      p.textContent = msg;
      result.appendChild(p);
    }

    function appendError(msg) {
      const p = document.createElement('p');
      p.style.color = 'crimson';
      p.textContent = 'エラー: ' + msg;
      result.appendChild(p);
    }

    function clearResults() { result.innerHTML = ''; }

    // イベント
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { runQuery(); }
    });
    document.getElementById('runBtn').addEventListener('click', runQuery);
    document.getElementById('resetBtn').addEventListener('click', () => { seed(); runQuery(); });
    document.querySelectorAll('button[data-snippet]').forEach(btn => {
      btn.addEventListener('click', () => {
        sqlInput.value = btn.getAttribute('data-snippet');
        runQuery();
      });
    });

    // かんたん検索ロジック
    function runSQL(sql){ sqlInput.value = sql; runQuery(); }
    function buildSearchSQL(q, type){
      const esc = q.replace(/'/g, "''");
      if(type === 'author'){
        return `SELECT h.id, h.text AS haiku, a.name AS author\nFROM haiku h LEFT JOIN authors a ON h.author_id=a.id\nWHERE a.name LIKE '%${esc}%';`;
      } else if(type === 'kigo'){
        return `SELECT h.id, h.text AS haiku, a.name AS author, k.term AS kigo\nFROM haiku h LEFT JOIN authors a ON h.author_id=a.id\nLEFT JOIN kigo k ON h.kigo_id=k.id\nWHERE k.term LIKE '%${esc}%';`;
      } else if(type === 'season'){
        return `SELECT h.id, h.text AS haiku, a.name AS author, s.name AS season\nFROM haiku h LEFT JOIN authors a ON h.author_id=a.id\nLEFT JOIN kigo k ON h.kigo_id=k.id\nLEFT JOIN seasons s ON k.season_id=s.id\nWHERE s.name LIKE '%${esc}%';`;
      } else { // text
        return `SELECT h.id, h.text AS haiku, a.name AS author\nFROM haiku h LEFT JOIN authors a ON h.author_id=a.id\nWHERE h.text LIKE '%${esc}%';`;
      }
    }
    const qInput = document.getElementById('qInput');
    const qType  = document.getElementById('qType');
    document.getElementById('qRun').addEventListener('click', () => {
      const q = (qInput.value || '').trim(); if(!q) return; runSQL(buildSearchSQL(q, qType.value));
    });
    document.querySelectorAll('.chip').forEach(b => {
      b.addEventListener('click', () => {
        const q = b.getAttribute('data-q');
        const t = b.getAttribute('data-type');
        qInput.value = q; qType.value = t; runSQL(buildSearchSQL(q, t));
      });
    });
  </script>
</body>
</html>
